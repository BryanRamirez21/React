next.js

recuerda que la logica de un componente es que es un tag, crear un componente es crear un tag que se renderiza en app.jsin

la reactividad es una de las propiedades mas importantes de node ya que los hace reactivos, es decir, un componente se llama a si mismo pero ahora toma un valor diferente en una actualizacion.

---------------------------------------

npm create vite@latest

para usarlo es en el file "main.jsx"

----------------------------------------

importante saber que es un syntethic event (aun no lo se)

-----------

CADA COMPONENTE SE EXPORTA/IMPORTA EN MAYUS

------------------------

hay un hook llamado forwardRef, que es para heredar props

---------------------------

useImperativeHandle, nos permite perzonalizar un value de una funcion del DOM (exponer funciones del dom para que otro elemento lo pueda usar)

--------------------------------
cada componente debe ser emebebido, es decir, cada componente que haga debe existir dentro 
de un <div> o de un <>


---------------------------

IMPORTANTE, NO FUNCIONA HACER "let uno, dos = useRef()" TIENE QUE SER SEPARADO

symbol, es un objeto que es unico (tal vez igual a un indice) en js

PRACTICAR EL USECALLBACK 
------------------------------

en react no se usa mucho el try-catch, ya que hay varias formas de detectar errores, como los "boundaries"

VISISTA LA PAGINA "USEHOOKS, TANSTACK QUERY"

-----------------------------------

lets install axios (some library to fetch...?)
in our dir proyect, wew go to the console, npm i axios

------------------------------------------
there are some libraries (like react-router-dom (EG BOOTCAMP/zustand) ) are necesary to use on the main.jsx

----------------------------------------------

look up for "immer" (eg. bootcamp/zustand/state/stores/user-info.ts)
immer has the persist func (also same eg above)
-----------------------------------------------
the use context main goal its to transffer info not needing events

------------------------------------------------

<input name='nombre' type='text' {...register("nombre", { required: "Este campo es obligatorio" })} />
                {errors.nombre && <span>{errors.nombre.message}</span>}

------------------------------------------------

yup es una buena libreria para hacer validaciones

-----------------------------------------------------

para los test, cambie:
"test": "vitest"
y por alguna razon daba error: "type:module"

the " aria-label:'' " helps us for the test can get a tag by the func "getByRole()"

--------------------------------------------------------

you can use props to reverse send them (like send from a form to a father component)

git rm -r --cached src/UdemyBC

------------------------------------------------------------
when you say "callback" you mean: "() => ({}) / ()"
eg: "a function w a callback === func(() => ({}))
    await waitFor(
            () => expect(result.current.images.length).toBeGreaterThan(0)
    );

in order to modify a state, you have to modify all the prop of the state, not just use setState and set vals, you have to do it like this:
 const [counter, setCounter] = useState({
        counter1: 10,
        counter2: 10,
        counter3: 10,
    });
<button onClick={() => setCounter({
        counter1: counter.counter1 + 1,
        counter2: counter.counter2 + 1,
        counter3: counter.counter3 + 1,
            })}>+1</button>
------------------------------------------------------------------------
in order to change a state from an input value without calling the state prop name, go to src\UdemyBC\05-Hook-App\02-useEffect\SimpleForm.jsx
(Seccion 9, cap 123)
--------------------------------------------------------------------------
in a async func, you must use the await until you use the data (ref. \UdemyBC\05-Hook-App\03-functionalComponents\hooks\useFetch.js)

"data?.name" === "if we have 'data' look up for prop 'name'"

deestructuring props:
 1- <PokemonCard id={data.id} name={data.name} sprites={data.sprites}/>
 2- export const PokemonCard = ({id, name, sprites = [] }) =>{}
(ref. \UdemyBC\05-Hook-App\03-functionalComponents\MultipleCustomHooks.js)  
-------------------------------------------------------------------------------
we use the memo when we want to memorize a component with its params (not callbacks)
 and we use useCallback when we want to memorize component callbacks (not params)
 (ref. \UdemyBC\05-Hook-App\05-memos\memorize.js && CallBackHook.js) && (ref. \UdemyBC\05-Hook-App\06-tarea-memo\)
 (secc 9 / ep 136)
 -------------------------------------------------------------------------------------------
 different ways to call useCallback:

 const toggleComplete = useCallback((id) => {
    setTasks(tasks.map(task => (
        task.id === id ? { ...task, completed: !task.completed } : task
    )));
},[]);

const decrement = useCallback( 
    () => {setCounter((prevCount) => prevCount - 1) },
[])
--------------------------------------------------------------------------------------
useReducer its a pure function, the main goals of a pure function are:
 - must not have side effects or call another functions..?
 - must not have async task, always sync
 - always must return an state
 - must not call the "localStorage / sessionStorage" (are considered side effects)
 - in order to modify the state, we must not need more than one action
 
 A reducer function, always has 2 params: the state and an action (the part that will tell the reducer how its suppose to change the state)

 its similar to declare a function, wich will recive an state and an action, the action will work like a switch param inside the reducer, depending on the action, will do an especific task 
 (ref. \UdemyBC\05-Hook-App\07-useReducer\intro-reducerORG.js)

You must not use push to push an state, NEVER, you must use the spread operator to push into an state